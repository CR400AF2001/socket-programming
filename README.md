# socket-programming

## 基于 Java Socket API 搭建简单的 HTTP 客户端和服务器端程序

1. 不允许基于 netty 等框架，完全基于 Java Socket API 进行编写 
2. 不分区使用的 IO 模型，BIO、NIO 和 AIO 都可以 
3. 实现基础的 HTTP 请求、响应功能，具体要求如下：
   - HTTP 客户端可以发送请求报文、呈现响应报文（命令行和 GUI 都可以） 
   - HTTP 客户端对 301、302、304 的状态码做相应的处理 
   - HTTP 服务器端支持 GET 和 POST 请求 
   - HTTP 服务器端支持 200、301、302、304、404、405、500 的状态码 
   - HTTP 服务器端实现长连接 3.6 MIME 至少支持三种类型，包含一种非文本类型 
4. 基于以上的要求，实现注册，登录功能(数据无需持久化，存在内存中即可， 只需要实现注册和登录的接口，可以使用 postman 等方法模拟请求发送，无需客 户端)。

### 分析

- socket是使用TCP协议为我们建立了传输层的连接，因此我们要实现基因应用层HTTP协议的通信应用
  - 约束客户端服务端的通信内容，达到实现协议的目的
- 功能是实现注册登录

![时序图](https://courseimg-loopchen.oss-cn-guangzhou.aliyuncs.com/Computer_Network/project_img/%E6%97%B6%E5%BA%8F%E5%9B%BE.png?Expires=1620751897&OSSAccessKeyId=TMP.3KgGYQMmtBsVYELGFpvVYvhuob7PDMJW1vF34yJPhkRyQfEMwPRooHrnc954YaHmUB5mqeGXsWASUE6rTxqcU2G15abcLH&Signature=csN1eZSF2Ap1n9qd3Op3nL8qjPk%3D&versionId=CAEQBxiBgIDiwcDwyhciIDJlNjExNDE4YzVhMTRhNGViMjRmMjgyMjA5MTE2ZmU3&response-content-type=application%2Foctet-stream)

### BIO NIO AIO

# 理解 IO

> 输入输出（IO）是指计算机同任何外部设备之间的数据传递。常见的输入输出设备有文件、键盘、打印机、屏幕等。数据可以按记录（或称数据块）的方式传递，也可以 流的方式传递 。
>
> 所谓记录，是指有着内部结构的数据块。记录内部除了有需要处理的实际数据之外，还可能包含附加信息，这些附加信息通常是对本记录数据的描述。

## 同步和异步

### 同步

- 概念：指的是用户进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否就绪。
- 例子：每天要吃饭，下班后自己跑去菜市场买菜，回来在做饭，所有的事情都是自己一件接着一件执行的。

### 异步

- 概念：异步是指用户进程触发IO操作以后便开始做自己的事情，而当 IO 操作已经完成的时候会得到 IO 完成的通知（异步的特点就是通知）。
- 例子：在某超市网上APP上选中食材后下单，委托快递员送菜上门，超市给你备货，快递员送货，而你在他们备货送菜的阶段还可以做其他事情。（使用异步 IO 时，Java 将 IO 读写委托给 OS 处理，需要将数据缓冲区地址和大小传给 OS ）。

### 区别

IO 操作主要分为两个步骤，即发起 IO 请求和实际 IO 操作，同步与异步的区别就在于第二个步骤是否阻塞。

若实际 IO 操作阻塞请求进程，即请求进程需要等待或者轮询查看 IO 操作是否就绪，则为同步 IO；若实际 IO 操作并不阻塞请求进程，而是由操作系统来进行实际 IO 操作并将结果返回，则为异步 IO。

计算把内存分为用户内存和系统内存两部分，同步和异步是针对应用程序(用户内存)和内核(系统内存)的交互而言的。

## 阻塞和非阻塞

### 阻塞

- 概念：所谓阻塞方式就是指，当视图对文件描述符或者网络套接字进行读写时，如果当时没有东西可读，或者暂时不可写，程序就进入等待状态，直到有东西读或者写。
- 例子：去公交站充值，发现这个时候，充值员不在（可能上厕所去了），然后我们就在这里等待，一直等到充值员回来为止。

### 非阻塞

- 概念：所谓的非阻塞方式就是指，当视图对文件描述符或者网络套接字进行读写时，如果没有东西可读，或者不可写，读写函数马上返回，无须等待。
- 例子：银行里取款办业务时，领取一张小票，领取完后我们自己可以玩玩手机，或者与别人聊聊天，当轮我们时，银行的喇叭会通知，这时候我们就可以去了。

### 区别

IO 操作主要分为两个步骤，即发起 IO 请求和实际 IO 操作，阻塞与非阻塞的区别就在于第一个步骤是否阻塞。

**若发起 IO 请求后请求线程一直等待实际 IO 操作完成，则为阻塞 IO；若发起 IO 请求后请求线程返回而不会一直等待，即为非阻塞 IO。**

**阻塞和非阻塞是针对于进程在访问数据的时候，根据 IO 操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。**

## 同步阻塞和同步非阻塞

### 同步阻塞（JAVA BIO）

同步并阻塞 IO，服务器实现模式一个连接一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情，就会造成不必要的线程开销，当然可以通过线迟（Thread-Pool）程机制改善。



![img](https://raw.githubusercontent.com/joyven/draw.io/master/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E.png)



图1 同步阻塞

Note: linux 内核中通常基于 Netlink 协议簇实现用户空间和内核空间的通讯。这里的系统调用指代是`recvfrom`过程，其实现逻辑大致如下：



![img](https://images0.cnblogs.com/blog/479389/201402/202305259961651.jpg)



图2 Netlink协议簇用户态和内核态通讯流程 图片来源：https://www.cnblogs.com/mosp/p/3558506.html

● 用户空间：

创建流程大体如下：

- ① 创建 socket 套接字
- ② 调用 bind 函数完成地址的绑定，不过同通常意义下 server 端的绑- 定还是存在一定的差别的，server端通常绑定某个端口或者地址，而此处的绑定则是 将 socket 套接口与本进程的 pid 进行绑定 ；
- ③ 通过 sendto 或者sendmsg函数发送消息；
- ④ 通过 recvfrom 或者 rcvmsg 函数接受消息。

● 内核空间：

内核空间主要完成以下三方面的工作：

- ① 创建 netlinksocket，并注册回调函数，注册函数将会在有消息到达 netlinksocket 时会执行；
- ② 根据用户请求类型，处理用户空间的数据；
- ③ 将数据发送回用户。

### 同步非阻塞（JAVA NIO）

同步非阻塞，服务器实现模式一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程处理。用户进程也需要时不时地询问IO操作是否就绪，这就要求用户进程不停的去询问。



![img](https://raw.githubusercontent.com/joyven/draw.io/master/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E.png)



图3 同步非阻塞

## 异步阻塞和异步非阻塞

### 异步阻塞（Java NIO）

异步阻塞，应用发起一个 IO 操作以后，不需要等待内核 IO 操作完成，等待内核完成 IO 操作以后会通知应用程序，这其实就是异步和同步的关键区别，同步必须等待或者主动去询问 IO 操作是否完成。那为什么说阻塞呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式就是阻塞的，但采用 select 函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select 属于同步操作。因为 select 之后，进程还需要读写数据），从而提高系统的并发性。



![img](https://raw.githubusercontent.com/joyven/draw.io/master/%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E.png)



图4 异步阻塞

### 异步非阻塞（Java AIO）

异步非阻塞，此种方式下，用户进程只需要发起一个IO操作便立即返回，等 IO 操作真正完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据处理就好了，不需要进行实际的 IO 读写操作，因为真正的 IO 操作已经由操作系统内核完成了。



![img](https://raw.githubusercontent.com/joyven/draw.io/master/%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E.png)



图5 异步非阻塞